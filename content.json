{"meta":{"title":"A Fish","subtitle":"学习, 分享, 提升","description":"Learn, Share","author":"LI YU","url":"https://www.1emo.net","root":"/"},"pages":[],"posts":[{"title":"字节码入门","slug":"字节码入门","date":"2021-08-07T06:06:01.000Z","updated":"2021-08-08T05:33:00.977Z","comments":true,"path":"2021/08/07/字节码入门/","link":"","permalink":"https://www.1emo.net/2021/08/07/%E5%AD%97%E8%8A%82%E7%A0%81%E5%85%A5%E9%97%A8/","excerpt":"","text":"介绍 当我们写了第一个Java程序，也就是“Hello World”时，我们会使用javac (filename).java 编译，会得到(filename).class字节码文件。 通过使用命令javap -verbose可以查看(filename).class的详细内容。 本文章我们会首先了解下关于JVM的字节码指令相关内容。 字节码标准以下内容基于JDK11，来自The Java® Virtual Machine Specification 关于这些内容,需要注意的是: 1. 表格仅仅是为了速查, 关于更加每个指令更加详细的内容需要查看上面的连接 字节码类型表达字节码中使用下面的标识符来表示操作元素的类型 Java 字节码 类型 描述 B byte 有符号字节 C char Unicode 字符 D double 双精度浮点数值 F float 单精度浮点数值 I int 整型 J long 长整型 L reference 类的实例 S short 有符号的短型 Z boolean 布尔类型 [ reference 一维数组 指令前缀/后缀通常一些操作数据的字节码指令会有前缀或后缀，例如iadd字节码指令，就是对两个int类型的数据进行加法操作。 Prefix/suffix Operand type 描述 i integer 整型 l long 长整型 s short 短整型 b byte 字节 c character 字符 f float 单浮点数 d double 双浮点数 a reference 引用类型 指令列表 字节码 操作数(in hex) 命令形式 操作数栈 [before]→[after] 描述 aaload 32 aaload arrayref, index → value 从arrayref的index位置加载一个引用类型并且压入操作数栈 aastore 53 aastore arrayref, index, value → 从操作数栈中读取arrayref, index, value并向arrayref的执行index位置放入value aconst_null 01 aconst_null → null 将一个null引用压入操作数栈 aload 19 aloadindex → objectref 从当前帧中的本地变量数组的index位置中加载一个引用类型并压入操作数栈 aload_0 2a aload_0 → objectref 从当前帧中的本地变量数组的0位置中加载一个引用类型并压入操作数栈 aload_1 2b aload_1 → objectref 从当前帧中的本地变量数组的1位置中加载一个引用类型并压入操作数栈 aload_2 2c aload_2 → objectref 从当前帧中的本地变量数组的2位置中加载一个引用类型并压入操作数栈 aload_3 2d aload_3 → objectref 从当前帧中的本地变量数组的3位置中加载一个引用类型并压入操作数栈 anewarray bd anewarrayindexbyte1indexbyte2 count → arrayref 创建一个数组，长度由从操作数栈中弹出的count指定，类型由在当前类常量池中的index((indexbyte1 &lt;&lt; 8) | indexbyte2)位置的值决定. areturn b0 areturn objectref → [empty] 从当前的帧中弹出返回的对象引用并且压入调用者的帧中，并且抛弃当前帧中其他的所有值 arraylength be arraylength arrayref → length 从操作数栈中弹出数组引用并且将长度(int)压入操作数栈 astore 3a astoreindex objectref → 将引用对象从操作数栈中弹出并且放入本地变量数组中的index位置 astore_0 4b astore_0 objectref → 将引用对象从操作数栈中弹出并且放入本地变量数组中的0位置 astore_1 4c astore_1 objectref → 将引用对象从操作数栈中弹出并且放入本地变量数组中的1位置 astore_2 4d astore_2 objectref → 将引用对象从操作数栈中弹出并且放入本地变量数组中的2位置 astore_3 4e astore_3 objectref → 将引用对象从操作数栈中弹出并且放入本地变量数组中的3位置 athrow bf athrow objectref → [empty], objectref 从操作数栈中弹出一个异常类型，如果当前帧中存在异常处理程序，则清空当前帧的操作数栈，并且将PC寄存器定位至异常程序的地址，并且继续执行；如果当前帧中不存在异常处理程序，则找寻调用者的帧，如果不存在这样的栈帧，则退出当前线程 baload 33 baload arrayref, index → value 从操作数栈中弹出arrayref和index，在arrayref的index位置获取一个byte或boolean值，以int的形式压入栈帧 bastore 54 bastore arrayref, index, value → 从操作数栈中弹出arrayref, index, value(boolean或byte)，并且将value放入arrayref的index位置 bipush 10 bipushbyte → value 将byte作为integer类型压入操作数栈 caload 34 caload arrayref, index → value 从操作数栈弹出arrayref, index，并且在arrayref的index位置加载一个char类型的值并且压入操作数栈 castore 55 castore arrayref, index, value → 从操作数栈弹出arrayref, index, value, 并且将value放入arrayref的index位置 checkcast c0 checkcastindexbyte1indexbyte2 objectref → objectref 从操作数栈中弹出objectref, 检查它是否属于位于常量池(indexbyte1 &lt;&lt; 8 |indexbyte2)位置的类型，如果是，则操作数栈不变，如果不是，则抛出ClassCastException d2f 90 d2f value → result 将double类型的value弹出操作数栈并且转换为float类型后压入操作数栈 d2i 8e d2i value → result 将double类型的value弹出操作数栈并且转换为integer类型后压入操作数栈 d2l 8f d2l value → result 将double类型的value弹出操作数栈并且转换为long类型后压入操作数栈 dadd 63 dadd value1, value2 → result 弹出value1(double)和value2(double)相加后压入操作数栈 daload 31 daload arrayref, index → value 从arrayref的index位置加载一个double类型并且压入操作数栈 dastore 52 dastore arrayref, index, value → 从操作数栈中读取arrayref, index, value并向arrayref的执行index位置放入value dcmpg 98 dcmp value1, value2 → result 比较操作数栈顶的两个double类型的值，如果value1大于value2 则将1压入操作数栈, 否则-1，相等则0 dcmpl 97 dcmp value1, value2 → result 与上面的指令结果相反 dconst_0 0e dconst_ → 0.0 将0.0(a double)压入操作数栈 dconst_1 0f dconst_ → 1.0 将1.0(a double)压入操作数栈 ddiv 6f ddiv value1, value2 → result 弹出操作数栈顶的两个double值并且相除，结果压入操作数栈 dload 18 dloadindex → value 从当前帧中的本地变量数组的index位置中加载一个double类型并压入操作数栈 dload_0 26 dload_ → value 从当前帧中的本地变量数组的0位置中加载一个double类型并压入操作数栈 dload_1 27 dload_ → value 从当前帧中的本地变量数组的1位置中加载一个double类型并压入操作数栈 dload_2 28 dload_ → value 从当前帧中的本地变量数组的2位置中加载一个double类型并压入操作数栈 dload_3 29 dload_ → value 从当前帧中的本地变量数组的3位置中加载一个double类型并压入操作数栈 dmul 6b dmul value1, value2 → result 弹出操作数栈顶的两个double值并且相乘，结果压入操作数栈 dneg 77 dneg value → result 弹出操作数栈顶的double值并且取反，结果压入操作数栈 drem 73 drem value1, value2 → result 弹出操作数栈顶的两个double值并且相除,结果取余并压入操作数栈 dreturn af dreturn value → [empty] 从当前的帧中弹出返回的double并且压入调用者的帧中，并且抛弃当前帧中其他的所有值 dstore 39 dstoreindex value → 将double值从操作数栈中弹出并且放入本地变量数组中的index位置 dstore_0 47 dstore_ value → 将double值从操作数栈中弹出并且放入本地变量数组中的0位置 dstore_1 48 dstore_ value → 将double值从操作数栈中弹出并且放入本地变量数组中的1位置 dstore_2 49 dstore_ value → 将double值从操作数栈中弹出并且放入本地变量数组中的2位置 dstore_3 4a dstore_ value → 将double值从操作数栈中弹出并且放入本地变量数组中的3位置 dsub 67 dsub value1, value2 → result 弹出操作数栈顶的两个double元素并且相减, 结果压入操作数栈 dup 59 dup value → value, value 复制操作数栈顶的元素并且压入操作数栈(栈顶元素不能是long或double) dup_x1 5a dup_x1 value2, value1 → value1, value2, value1 复制操作数栈顶的元素并且压入操作数栈顶2个元素之后位置(栈顶元素不能是long或double) dup_x2 5b dup_x2 value3, value2, value1 → value1, value3, value2, value1 复制操作数栈顶的元素并且压入操作数栈顶3个元素之后位置(栈顶元素不能是long或double) dup2 5c dup2 {value2, value1} → {value2, value1}, {value2, value1} 复制操作数栈顶的一个或两个元素再压入操作数栈(如果栈顶的两个元素都不是long和double,则复制两个元素, 如果栈顶的元素是long或double, 则复制一个) dup2_x1 5d dup2_x1 value3, {value2, value1} → {value2, value1}, value3, {value2, value1} 同上, 但复制的数插入位置在前四个元素之后的位置(复制两个值的情况下), 或前三个元素之后的位置(复制一个数的情况下). dup2_x2 5e dup2_x2 {value4, value3}, {value2, value1} → {value2, value1}, {value4, value3}, {value2, value1} 情况很多, 详情查看文档说明 f2d 8d f2d value → result 将float类型的value弹出操作数栈并且转换为double类型后压入操作数栈 f2i 8b f2i value → result 将float类型的value弹出操作数栈并且转换为integer类型后压入操作数栈 f2l 8c f2l value → result 将float类型的value弹出操作数栈并且转换为long类型后压入操作数栈 fadd 62 fadd value1, value2 → result 弹出value1(float)和 value2(float)相加后压入操作数栈 faload 30 faload arrayref, index → value 从arrayref的index位置加载一个 float类型并且压入操作数栈 fastore 51 fastore arrayref, index, value → 从操作数栈中读取arrayref, index, value并向arrayref的执行index位置 放入value fcmpg 96 fcmp value1, value2 → result 比较操作数栈顶的两个float类型的 值，如果value1大于value2 则将1压 入操作数栈, 否则-1，相等则0 fcmpl 95 fcmp value1, value2 → result 与上面的指令结果相反 fconst_0 0b fconst_ → 0.0f 将0.0f压入操作数栈 fconst_1 0c fconst_ → 1.0f 将1.0f压入操作数栈 fconst_2 0d fconst_ → 2.0f 将2.0f压入操作数栈 fdiv 6e fdiv value1, value2 → result 弹出操作数栈顶的两个float值并且 相除，结果压入操作数栈 fload 17 floadindex → value 从当前帧中的本地变量数组的index位 置中加载一个double类型并压入操作 数栈 fload_0 22 fload_ → value 从当前帧中的本地变量数组的0位 置中加载一个double类型并压入操作 数栈 fload_1 23 fload_ → value 从当前帧中的本地变量数组的1位 置中加载一个double类型并压入操作 数栈 fload_2 24 fload_ → value 从当前帧中的本地变量数组的2位 置中加载一个double类型并压入操作 数栈 fload_3 25 fload_ → value 从当前帧中的本地变量数组的3位 置中加载一个double类型并压入操作 数栈 fmul 6a fmul value1, value2 → result 弹出操作数栈顶的两个float值并且 相乘，结果压入操作数栈 fneg 76 fneg value → result 弹出操作数栈顶的float值并且取 反，结果压入操作数栈 frem 72 frem value1, value2 → result 弹出操作数栈顶的两个float值并且 相除,结果取余并压入操作数栈 freturn ae freturn value → [empty] 从当前的帧中弹出返回的float并且 压入调用者的帧中，并且抛弃当前帧 中其他的所有值 fstore 38 fstoreindex value → 将double值从操作数栈中弹出并且放 入本地变量数组中的index位置 fstore_0 43 fstore_ value → 将double值从操作数栈中弹出并且放 入本地变量数组中的0位置 fstore_1 44 fstore_ value → 将double值从操作数栈中弹出并且放 入本地变量数组中的1位置 fstore_2 45 fstore_ value → 将double值从操作数栈中弹出并且放 入本地变量数组中的2位置 fstore_3 46 fstore_ value → 将double值从操作数栈中弹出并且放 入本地变量数组中的3位置 fsub 66 fsub value1, value2 → result 弹出操作数栈顶的两个float元素并 且相减, 结果压入操作数栈 getfield b4 getfieldindexbyte1indexbyte2 objectref → value 从栈顶的对象引用的对象中获取字段值, 字段的标识引用在常量池的(indexbyte1 &lt;&lt; 8 |indexbyte2)位置 getstatic b2 getstaticindexbyte1indexbyte2 → value 获取一个class的静态字段, 字段表示引用在常量池的(indexbyte1 &lt;&lt; 8 |indexbyte2)位置 goto a7 gotobranchbyte1branchbyte2 [no change] 从这个goto指令的地址开始, 跳转到branchoffset, branchoffset 是 (branchbyte1 &lt;&lt; 8) |branchbyte2 goto_w c8 goto_wbranchbyte1branchbyte2branchbyte3branchbyte4 [no change] 跟上面一样,只不过branchoffset变为(signed int constructed from unsigned bytes branchbyte1 &lt;&lt; 24 | branchbyte2 &lt;&lt; 16 | branchbyte3 &lt;&lt; 8 | branchbyte4) i2b 91 i2b value → result 将integer类型的value弹出操作数栈并且 转换为byte类型后压入操作数栈 i2c 92 i2c value → result 将integer类型的value弹出操作数栈并且 转换为char类型后压入操作数栈 i2d 87 i2d value → result 将integer类型的value弹出操作数栈并且 转换为double类型后压入操作数栈 i2f 86 i2f value → result 将integer类型的value弹出操作数栈并且 转换为float类型后压入操作数栈 i2l 85 i2l value → result 将integer类型的value弹出操作数栈并且 转换为long类型后压入操作数栈 i2s 93 i2s value → result 将integer类型的value弹出操作数栈并且 转换为short类型后压入操作数栈 iadd 60 iadd value1, value2 → result 弹出value1(int)和 value2(int)相 加后压入操作数栈 iaload 2e iaload arrayref, index → value 从arrayref的index位置加载一个 int类型并且压入操作数栈 iand 7e iand value1, value2 → result 从操作数栈顶弹出两个int, 对它们进行AND操作, 结果压入操作数栈 iastore 4f iastore arrayref, index, value → 从操作数栈中读取arrayref, index, value并向arrayref的执行index位置 放入value iconst_m1 02 iconst_ → -1 将int常量, 值为-1压入操作数栈 iconst_0 03 iconst_ → 0 将int常量, 值为0压入操作数栈 iconst_1 04 iconst_ → 1 将int常量, 值为1压入操作数栈 iconst_2 05 iconst_ → 2 将int常量, 值为2压入操作数栈 iconst_3 06 iconst_ → 3 将int常量, 值为3压入操作数栈 iconst_4 07 iconst_ → 4 将int常量, 值为4压入操作数栈 iconst_5 08 iconst_ → 5 将int常量, 值为5压入操作数栈 idiv 6c idiv value1, value2 → result 弹出操作数栈顶的两个int值并且 相除，结果压入操作数栈 if_acmpeq a5 if_acmpbranchbyte1branchbyte2 value1, value2 → 如果栈顶两个引用对象相等, 则跳转, 跳转地址从这条指令开始, 偏移量是branchoffset (signed short constructed from unsigned bytes branchbyte1 &lt;&lt; 8 | branchbyte2) if_acmpne a6 if_acmpbranchbyte1branchbyte2 value1, value2 → 如果栈顶两个引用对象不相等, 则跳转, 跳转地址从这条指令开始, 偏移量是branchoffset (signed short constructed from unsigned bytes branchbyte1 &lt;&lt; 8 |branchbyte2) if_icmpeq 9f if_icmpbranchbyte1branchbyte2 value1, value2 → 如果栈顶两个int相等, 则跳转, 跳转地址从这条指令开始, 偏移量是branchoffset (signed short constructed from unsigned bytes branchbyte1 &lt;&lt; 8 |branchbyte2) if_icmpge a2 if_icmpbranchbyte1branchbyte2 value1, value2 → 如果栈顶value1 ≥ value2, 则跳转, 跳转地址从这条指令开始, 偏移量是branchoffset (signed short constructed from unsigned bytes branchbyte1 &lt;&lt; 8 |branchbyte2) if_icmplt a3 if_icmpbranchbyte1branchbyte2 value1, value2 → 如果栈顶value1 &lt; value2, 则跳转, 跳转地址从这条指令开始, 偏移量是branchoffset (signed short constructed from unsigned bytes branchbyte1 &lt;&lt; 8 |branchbyte2) if_icmple a4 if_icmpbranchbyte1branchbyte2 value1, value2 → 如果栈顶value1 ≥ value2, 则跳转, 跳转地址从这条指令开始, 偏移量是branchoffset (signed short constructed from unsigned bytes branchbyte1 &lt;&lt; 8 |branchbyte2) if_icmplt a1 if_icmpbranchbyte1branchbyte2 value1, value2 → 如果栈顶value1 ≤ value2, 则跳转, 跳转地址从这条指令开始, 偏移量是branchoffset (signed short constructed from unsigned bytes branchbyte1 &lt;&lt; 8 |branchbyte2) if_icmpne a0 if_icmpbranchbyte1branchbyte2 value1, value2 → 如果栈顶value1 ≠ value2, 则跳转, 跳转地址从这条指令开始, 偏移量是branchoffset (signed short constructed from unsigned bytes branchbyte1 &lt;&lt; 8 |branchbyte2) ifeq 99 ifbranchbyte1branchbyte2 value → 如果栈顶value = 0, 则跳转, 跳转地址从这条指令开始, 偏移量是branchoffset (signed short constructed from unsigned bytes branchbyte1 &lt;&lt; 8 |branchbyte2) ifge 9c ifbranchbyte1branchbyte2 value → 如果栈顶value ≥ 0, 则跳转, 跳转地址从这条指令开始, 偏移量是branchoffset (signed short constructed from unsigned bytes branchbyte1 &lt;&lt; 8 |branchbyte2) ifgt 9d ifbranchbyte1branchbyte2 value → 如果栈顶value &gt; 0, 则跳转, 跳转地址从这条指令开始, 偏移量是branchoffset (signed short constructed from unsigned bytes branchbyte1 &lt;&lt; 8 |branchbyte2) ifle 9e ifbranchbyte1branchbyte2 value → 如果栈顶value ≤ 0, 则跳转, 跳转地址从这条指令开始, 偏移量是branchoffset (signed short constructed from unsigned bytes branchbyte1 &lt;&lt; 8 |branchbyte2) iflt 9b ifbranchbyte1branchbyte2 value → 如果栈顶value &lt; 0, 则跳转, 跳转地址从这条指令开始, 偏移量是branchoffset (signed short constructed from unsigned bytes branchbyte1 &lt;&lt; 8 |branchbyte2) ifne 9a ifbranchbyte1branchbyte2 value → 如果栈顶value ≠ 0, 则跳转, 跳转地址从这条指令开始, 偏移量是branchoffset (signed short constructed from unsigned bytes branchbyte1 &lt;&lt; 8 |branchbyte2) ifnonnull c7 ifnonnullbranchbyte1branchbyte2 value → 如果栈顶value不为null, 则跳转, 跳转地址从这条指令开始, 偏移量是branchoffset (signed short constructed from unsigned bytes branchbyte1 &lt;&lt; 8 |branchbyte2) ifnull c6 ifnullbranchbyte1branchbyte2 value → 如果栈顶value为null, 则跳转, 跳转地址从这条指令开始, 偏移量是branchoffset (signed short constructed from unsigned bytes branchbyte1 &lt;&lt; 8 |branchbyte2) iinc 84 iincindexconst [No change] 在局部变量数组的index位置的值上增加const iload 15 iloadindex → value 从arrayref的index位置加载一个 int类型并且压入操作数栈 iload_0 1a iload_ → value 从arrayref的0位置加载一个 int类型并且压入操作数栈 iload_1 1b iload_ → value 从arrayref的1位置加载一个 int类型并且压入操作数栈 iload_2 1c iload_ → value 从arrayref的2位置加载一个 int类型并且压入操作数栈 iload_3 1d iload_ → value 从arrayref的3位置加载一个 int类型并且压入操作数栈 imul 68 imul value1, value2 → result 弹出操作数栈顶的两个int值并且 相 乘，结果压入操作数栈 ineg 74 ineg value → result 弹出操作数栈顶的int值并且取 反， 结果压入操作数栈 instanceof c1 instanceofindexbyte1indexbyte2 objectref → result 判断栈顶对象是否是常量池中某个位置的类的对象 invokedynamic ba invokedynamicindexbyte1indexbyte200 [arg1, arg2, …] → result 调用方法标识符位于常量池某位置的方法, 并将结果压入操作数栈中 invokeinterface b9 invokeinterfaceindexbyte1indexbyte2count0 objectref, [arg1, arg2, …] → result 调用某个对象引用中的接口的方法, 接口方法的标识符位于常量池的某个位置, 结果压入操作数栈 invokespecial b7 invokespecialindexbyte1indexbyte2 objectref, [arg1, arg2, …] → result 调用对象的实例方法并将结果压入操作数栈, 方法标识符位于常量池的某个位置 invokestatic b8 invokestaticindexbyte1indexbyte2 [arg1, arg2, 调用静态方法, 方法标识符位于常量池的某个位置 invokevirtual b6 invokevirtualindexbyte1indexbyte2 objectref, [arg1, arg2, …] → result 调用对象的虚方法, 方法标识符位于常量池的某个位置 ior 80 ior value1, value2 → result 对操作数栈顶两个int进行或操作,结果压入操作数栈 irem 70 irem value1, value2 → result 对操作数栈顶两个int进行取余操作,结果压入操作数栈 ireturn ac ireturn value → [empty] 从当前的帧中弹出返回的int并且 压 入调用者的帧中，并且抛弃当前帧 中 其他的所有值 ishl 78 ishl value1, value2 → result 将value向左位移, 位移的长度等于value的低五位的值 ishr 7a ishr value1, value2 → result 将value向右位移, 位移的长度等于value的低五位的值 istore 36 istoreindex value → 将double值从操作数栈中弹出并且放 入本地变量数组中的index位置 istore_0 3b istore_ value → 将double值从操作数栈中弹出并且放 入本地变量数组中的0位置 istore_1 3c istore_ value → 将double值从操作数栈中弹出并且放 入本地变量数组中的1位置 istore_2 3d istore_ value → 将double值从操作数栈中弹出并且放 入本地变量数组中的2位置 istore_3 3e istore_ value → 将double值从操作数栈中弹出并且放 入本地变量数组中的3位置 isub 64 isub value1, value2 → result 弹出操作数栈顶的两个int元素并 且相减, 结果压入操作数栈 iushr 7c iushr value1, value2 → result 将value向右位移, 0扩展, 位移的长度等于value的低五位的值 ixor 82 ixor value1, value2 → result 对操作数栈顶两个int进行异或操作,结果压入操作数栈 jsr a8 jsrbranchbyte1branchbyte2 → address 跳转至subroutine(子程序), 返回地址压入栈帧 jsr_w c9 jsr_wbranchbyte1branchbyte2branchbyte3branchbyte4 → address 跳转至subroutine(子程序), 返回地址压入栈帧 l2d 8a l2d value → result 将double类型的long弹出操作数栈并 且转换为double类型后压入操作数栈 l2f 89 l2f value → result 将double类型的long弹出操作数栈并 且转换为float类型后压入操作数栈 l2i 88 l2i value → result 将double类型的long弹出操作数栈并 且转换为integer类型后压入操作数栈 ladd 61 ladd value1, value2 → result 弹出value1(long)和 value2(long)相加后压入操作数栈 laload 2f laload arrayref, index → value 从arrayref的index位置加载一个 long类型并且压入操作数栈 land 7f land value1, value2 → result 对value1和value2进行AND运算, 结果压入操作数栈 lastore 50 lastore arrayref, index, value → 从操作数栈中读取arrayref, index, value并向arrayref的执行index位置 放入value lcmp 94 lcmp value1, value2 → result 比较操作数栈顶的两个long类型的 值，如果value1大于value2 则将1压 入操作数栈, 否则-1，相等则0 lconst_0 09 lconst_ → 0L 将0L压入操作数栈 lconst_1 0a lconst_ → 1L 将1L压入操作数栈 ldc 12 ldcindex → value 将常量池中的某个元素 (String, int, float, Class, java.lang.invoke.MethodType, java.lang.invoke.MethodHandle, or a dynamically-computed constant) 的index压入操作数栈 ldc_w 13 ldc_windexbyte1indexbyte2 → value 将常量池中的某个元素 (String, int, float, Class, java.lang.invoke.MethodType, java.lang.invoke.MethodHandle, or a dynamically-computed constant) 的index(ndexbyte1 &lt;&lt; 8 |indexbyte2))压入操作数栈 i ldc2_w 14 ldc2_windexbyte1indexbyte2 → value 将常量池中的某个元素(double, long, or a dynamically-computed constant) 的index(ndexbyte1 &lt;&lt; 8 |indexbyte2))压入操作数栈 ldiv 6d ldiv value1, value2 → result 弹出操作数栈顶的两个long值并且 相除，结果压入操作数栈 lload 16 lloadindex → value 从当前帧中的本地变量数组的index位 置中加载一个long类型并压入操作 数栈 lload_0 1e lload_ → value 从当前帧中的本地变量数组的0位置中 加载一个long类型并压入操作数栈 lload_1 1f lload_ → value 从当前帧中的本地变量数组的1位置中 加载一个long类型并压入操作数栈 lload_2 20 lload_ → value 从当前帧中的本地变量数组的2位置中 加载一个long类型并压入操作数栈 lload_3 21 lload_ → value 从当前帧中的本地变量数组的3位置中 加载一个long类型并压入操作数栈 lmul 69 lmul value1, value2 → result 弹出操作数栈顶的两个long值并且 相乘，结果压入操作数栈 lneg 75 lneg value → result 弹出操作数栈顶的long值并且取 反，结果压入操作数栈 lookupswitch ab lookupswitch&lt;0-3 byte pad&gt;defaultbyte1defaultbyte2defaultbyte3defaultbyte4npairs1npairs2npairs3npairs4match-offset pairs… key → 使用键从表中查找目标地址，并从该地址的指令继续执行 lor 81 lor value1, value2 → result 对操作数栈顶两个int进行或操作,结果 压入操作数栈 lrem 71 lrem value1, value2 → result 对操作数栈顶两个int进行取余操作,结 果压入操作数栈 lreturn ad lreturn value → [empty] 从当前的帧中弹出返回的long并且 压 入 调用者的帧中，并且抛弃当前帧 中 其 他的所有值 lshl 79 lshl value1, value2 → result 将value向左位移, 位移的长度等于 value的低六位的值 lshr 7b lshr value1, value2 → result 将value向右位移, 位移的长度等于 value的低六位的值 lstore 37 lstoreindex value → 将long值从操作数栈中弹出并且放 入本地变量数组中的index位置 lstore_0 3f lstore_ value → 将long值从操作数栈中弹出并且放 入本地变量数组中的0位置 lstore_1 40 lstore_ value → 将long值从操作数栈中弹出并且放 入本地变量数组中的1位置 lstore_2 41 lstore_ value → 将long值从操作数栈中弹出并且放 入本地变量数组中的2位置 lstore_3 42 lstore_ value → 将long值从操作数栈中弹出并且放 入本地变量数组中的3位置 lsub 65 lsub value1, value2 → result 弹出操作数栈顶的两个long元素并 且相 减, 结果压入操作数栈 lushr 7d lushr value1, value2 → result 将value向右位移, 0扩展, 位移的长度 等于value的低六位的值 lxor 83 lxor value1, value2 → result 对操作数栈顶两个long进行异或操作, 结果压入操作数栈 monitorenter c2 monitorenter objectref → 进入对象的监视器(synchronized()的开始) monitorexit c3 monitorexit objectref → 退出对象的监视器(synchronized()的结束) multianewarray c5 multianewarrayindexbyte1indexbyte2dimensions count1, [count2,…] → arrayref 创建指定类型的多维数组 new bb newindexbyte1indexbyte2 → objectref 创建一个对象, 对象所属的类的标识符位于常量池的某个位置. newarray bc newarrayatype count → arrayref 创建一个count大小的atype类型的数组 nop 00 nop [No change] 不做任何操作 pop 57 pop value → 弹出操作数栈顶元素 pop2 58 pop2 {value2, value1} → 弹出栈顶的两个元素 (如果栈顶是long或者是double, 则弹出一个) putfield b5 putfieldindexbyte1indexbyte2 objectref, value → 为objectref所指的对象字段赋值, 字段标识符在常量池的某个位置 putstatic b3 putstaticindexbyte1indexbyte2 value → 为某个静态变量赋值, 静态变量的标识符在常量池的某个位置 ret a9 retindex [No change] 从子程序返回到index栈帧 return b1 return → [empty] 从当前帧返回void, 并压入调用者所属的帧的操作数栈中 saload 35 saload arrayref, index → value 从arrayref的index位置加载一个 short类型并且压入操作数栈 sastore 56 sastore arrayref, index, value → 将short值从操作数栈中弹出并且放 入本地变量数组中的index位置 sipush 11 sipushbyte1byte2 → value 将(byte1 &lt;&lt; 8)|byte2 压入操作数栈 swap 5f swap value2, value1 → value1, value2 交换栈顶两个元素","categories":[],"tags":[{"name":"Java Class系列","slug":"Java-Class系列","permalink":"https://www.1emo.net/tags/Java-Class%E7%B3%BB%E5%88%97/"}]}],"categories":[],"tags":[{"name":"Java Class系列","slug":"Java-Class系列","permalink":"https://www.1emo.net/tags/Java-Class%E7%B3%BB%E5%88%97/"}]}